@using System.Reflection
@using NYC311Dashboard.Extensions
@using NYC311Dashboard.Services.Models
@using System.Linq.Expressions

@typeparam TItem

@* todo: May turn off borders on table-responsive or v-wrapper. Otherwise change margins so they do not fill *@


    @foreach (var group in GetGroups())
    {
        <div class="@TableStyles">
            @if (GroupBy != null)
            {
                <h4>@group.Key</h4>
            }
            @RenderTable(group)
        </div>
    }

@code {
    [Parameter] public TableOptions<TItem>? Options { get; set; }
    [Parameter] public IEnumerable<TItem> Items { get; set; }

    private List<TItem> SortedItems => GetSortedItems();
    private PropertyInfo[] Properties => GetProperties();
    private PropertyInfo SortColumn { get; set; }
    private bool SortAscending { get; set; } = true;

    // Options
    private string? TableStyles;
    private Expression<Func<TItem, string>>? GroupBy;

    protected override void OnParametersSet()
    {
        SortColumn ??= GetProperties().First();
        TableStyles = Options?.TableStyles;
        GroupBy = Options?.GroupBy;
    }

    private void OnSort(PropertyInfo prop)
    {
        if (SortColumn == prop)
        {
            SortAscending = !SortAscending;
        }
        else
        {
            SortColumn = prop;
            SortAscending = true;
        }
    }

    private IEnumerable<IGrouping<string, TItem>> GetGroups()
    {
        if (GroupBy != null)
        {
            return Items.OrderBy(GroupBy.Compile()).GroupBy(GroupBy.Compile());
        }
        else
        {
            return Items.GroupBy(_ => string.Empty);
        }
    }

    private string? GetGroupByPropertyName()
    {
        //if (GroupBy == null) return null;
        if (GroupBy?.Body is MemberExpression member)
            return member.Member.Name; // returns "Borough"
        return null;
    }

    // Filter properties with all empty values
    private PropertyInfo[] GetProperties(IEnumerable<TItem>? items = null)
    {
        var source = items ?? Items;
        var groupByName = GetGroupByPropertyName();
        return typeof(TItem).GetProperties()
            .Where(p => !string.Equals(p.Name, groupByName, StringComparison.OrdinalIgnoreCase) && source.Any(item =>
            {
                var value = p.GetValue(item);
                if (value is string s) return (!string.IsNullOrEmpty(s));
                return value != null;
            }))
            .ToArray();
    }

    private List<TItem> GetSortedItems(IEnumerable<TItem>? items = null)
    {
        var source = items ?? Items;
        var properties = GetProperties(items);
        var filtered = source.Where(item =>
            properties.Any(p =>
            {
                var value = p.GetValue(item);
                if (value is string s) return !string.IsNullOrEmpty(s);
                return value != null;
            })
        );
        if (SortAscending)
        {
            return filtered.OrderBy(x => SortColumn.GetValue(x)).ToList();
        }
        else
        {
            return filtered.OrderByDescending(x => SortColumn.GetValue(x)).ToList();
        }
    }

    private RenderFragment RenderTable(IGrouping<string, TItem> group) => __builder =>
    {
        var groupItems = group as IEnumerable<TItem>;
        var properties = GetProperties(groupItems);
        var sortedItems = GetSortedItems(groupItems);

        <div class="table-responsive v-wrapper">
            <table class="table table-sm fixed-width-table">
                <thead>
                    <tr>
                        @foreach (var prop in properties)
                        {
                            <th>
                                @prop.Name.FromCamelCaseToProperSpaced()
                                <button class="icon-btn" @onclick="() => OnSort(prop)">
                                    <i class="bi @(SortColumn == prop ? (SortAscending ? "bi-sort-up" : "bi-sort-down") : "bi-arrow-down-up")"></i>
                                </button>
                            </th>
                        }
                    </tr>
                </thead>
                <tbody>
                    @foreach (var item in sortedItems)
                    {
                        <tr>
                            @foreach (var prop in properties)
                            {
                                var value = prop.GetValue(item);

                                <td>
                                    @if (value is double d)
                                    {
                                        @Math.Round(d, 2)
                                    }
                                    else if (value is string s && s.Length > 100)
                                    {
                                        <ExpandableCell Text="@s" MaxLength="100" />
                                    }
                                    else if (value is DateTime?)
                                    {
                                        DateTime? dateTime;
                                        if (value == null)
                                        {
                                            dateTime = null;
                                        }
                                        else
                                        {
                                            dateTime = (DateTime)value;
                                        }

                                        @dateTime.ToDateTimeHour()
                                    ;
                                    }
                                    else
                                    {
                                        @value
                                    }
                                </td>
                            }
                        </tr>
                    }
                </tbody>
            </table>
        </div>
    };
}